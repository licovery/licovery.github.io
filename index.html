<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Neo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Neo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Neo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neo">
  
    <link rel="alternate" href="/atom.xml" title="Neo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Neo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-Unix-信号处理signal-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/07/Linux-Unix-信号处理signal-函数/" class="article-date">
  <time datetime="2019-12-06T16:28:52.000Z" itemprop="datePublished">2019-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/07/Linux-Unix-信号处理signal-函数/">Linux/Unix 信号处理signal()函数的坑——为什么僵尸进程总是清理不掉？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>先说重点，<code>signal()</code>不是标准函数，行为在不同地方不一样，不要直接使用<code>signal()</code>！！！实在有需求的，自定义一个接口一样的函数来使用。</p>
<blockquote>
<p>The  behavior  of  signal()  varies across UNIX versions, and has also varied historically across different versions of Linux. ——man signal （Linux man 手册）</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近看Unix网络编程卷1：套接字联网API。第五章提到一个例子，服务器端利用<code>fork()</code>创建子进程来处理多个客户端的请求。如果子进程完成处理退出的时候，父进程不调用<code>wait()</code>或<code>waitpid()</code>处理子进程，子进程就会处于<strong>僵死</strong>状态，成为僵尸进程。如果僵死进程过多，很可能会耗尽系统的资源。</p>
<p>Linux/Unix系统保证，在一个进程终止或者停止时，它会发送<code>SIGCHLD</code>信号给其父进程。所以我们可以得到一种处理僵尸进程的方法：父进程设置<code>SIGCHID</code>的信号处理函数，并在信号处理函数中<code>wait()</code>或者<code>waitpid()</code>子进程。这就引出了这次讨论的重点信号处理和<code>signal()</code>函数。</p>
<h2 id="信号与signal-函数"><a href="#信号与signal-函数" class="headerlink" title="信号与signal()函数"></a>信号与signal()函数</h2><p>Linux/Unix系统定义了一组信号，用于处理异步事件。信号的例子有很多，终端用户输入了 Ctrl+c 来中断程序(<code>SIGINT</code>)，或者使用kill来杀死进程(<code>SIGKILL</code>)，又或者子进程结束(<code>SIGCHLD</code>)。对于大多数的信号（<code>SIGKILL</code>和<code>SIGSTOP</code>不能被捕获），可以捕获并设置对应的自定义处理函数。</p>
<p>自定义信号处理函数的原型长这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span>; <span class="comment">// 参数就是信号，信号都用宏表示，是一个大于0的值</span></span><br></pre></td></tr></table></figure>
<p><code>signal()</code>是一个定义在标准库&lt;signal.h&gt;的函数，来用设置对应信号的处理函数，就是这个函数坑了一天，后面再详细说。函数原型是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
<p>第一个参数<code>signum</code>就是要捕获的信号的值，第二个参数<code>sighandler_t</code>是自定义的信号处理函数。返回值和第二个参数类型一样，含义是前一次设置的信号处理函数，如果是第一次设置的话就返回默认处理函数(<code>SIG_DFL</code>)。</p>
<p>看起来很简单是不是？就根据信号设置一个回调函数就可以了，真方便。网上很多介绍<code>signal()</code>的，都是介绍一下用法，随便写几个样例就完了。但是有很重要的一点忽略了，<strong>signal()这个函数并不是标准函数</strong>，可能不同的机器，不同Linux，Unix内核版本，甚至在不同的<code>gcc</code>编译宏或者编译选项下会有不同的表现。</p>
<blockquote>
<p>signal是早于POSIX出现的历史悠久的函数。调用它时，不同的实现提供不同的信号语义环境以达成后向兼容——《Unix网络编程卷1：套接字联网API》 第五章p104</p>
</blockquote>
<p>接下来可以好好说说这个<code>signal()</code>的行为不确定是怎么影响的处理僵尸进程的。</p>
<h2 id="为什么僵尸进程总是清理不掉？"><a href="#为什么僵尸进程总是清理不掉？" class="headerlink" title="为什么僵尸进程总是清理不掉？"></a>为什么僵尸进程总是清理不掉？</h2><p>先贴一下代码，是一个多进程的echo回射的服务器，客户端发什么东西过去，原样返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span> <span class="comment">// 里面包含了很多socket unix相关的头文件，这个也很关键，后面解释</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//里面有些大写的函数例如Socket是封装了系统的socket加了错误处理，功能不改变。Read,Write,Bind等等同理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerProc</span><span class="params">(<span class="keyword">int</span> acceptFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX_BUF_SIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = Read(acceptFd, buf, MAX_BUF_SIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Writen(acceptFd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(acceptFd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理结束的子进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HandleSigchild</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> stat;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// IO不安全，仅调试</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process %d terminated\n"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenFd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serverAddr.sin_port = htons(ECHO_PORT - ECHO_PORT + <span class="number">9877</span>);</span><br><span class="line"></span><br><span class="line">    Bind(listenFd, (struct sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">    Listen(listenFd, MAX_LISTEN_CON);</span><br><span class="line"></span><br><span class="line">    signal(SIGCHLD, HandleSigchild); <span class="comment">//最重要的地方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// accept可能会被信号处理函数返回的时候打断</span></span><br><span class="line">        <span class="keyword">int</span> acceptFd = accept(listenFd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (acceptFd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                err_sys(<span class="string">"accept error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pid = Fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 子进程关闭listenFd</span></span><br><span class="line">            Close(listenFd);</span><br><span class="line">            ServerProc(acceptFd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 因为这里exit，子进程的作用范围只到这里，考虑处理僵尸进程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//父进程关闭acceptFd</span></span><br><span class="line">        Close(acceptFd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令：<code>gcc -g -std=c11 -Wall -I../comm -L../comm/build echo_server.c -lcomm -o echo_server</code>  用到了自己的静态库<code>libcomm.a</code></p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>当建立了n个子进程的时候，发现只有一个子进程被<code>waitpid()</code>处理了，其余的都变成了僵尸进程。似乎<code>HandleSigchild()</code>只被回调了一次，此时我考虑是否信号丢失了或者在哪里发生错误，只传递了一次过来。</p>
<h3 id="另外一个例子"><a href="#另外一个例子" class="headerlink" title="另外一个例子"></a>另外一个例子</h3><p>为了搞清楚<code>signal()</code>的用法，我又写了一个样例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait4children</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    signal(SIGCHLD, wait4children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"press Enter to exit..."</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令：<code>gcc -g test.c -o test</code>  </p>
<p>运行发现确实每一个子进程的SIGCHLD信号都捕获到了并且都进行了<code>waitpid()</code>处理，没有出现僵尸进程。</p>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>为什么我写了<code>socket</code>相关的代码，子进程的<code>SIGCHID</code>信号就没法处理了呢？想到Unix编程里面对<code>signal()</code>的描述，我开始在google上搜索signal相关资料。发现有不少人说：<strong>signal()设置信号的回调处理函数，是一次性的，当回调函数处理完一次，这个信号的处理函数会被设置回默认(SIG_DFL)，如果要处理多次信号，要重新调用signal()</strong>。仔细一想，也不对啊，那为什么我的<code>echo_server.c</code>的<code>signal()</code>是一次性的，我的<code>test.c</code>的<code>signal()</code>就是永久的啊？这个时候，我开始怀疑链接的时候，signal()这个符号链接到了不同的函数。</p>
<p>用<code>gdb</code>开始调试，发现<code>echo_server</code>的<code>signal</code>是<code>libc.so.6</code>里面的<code>sysv_signal</code>，而<code>test</code>的是<code>libc.so.6</code>的<code>bsd_signal</code>。同时我还用<code>objdump</code>搜索了一下两个可执行文件中<code>signal</code>的符号，发现确实不一样，证明了这两个<code>signal()</code>是两个函数。</p>
<p>命令：<code>objdump -tT echo_server | grep signal</code></p>
<p>似乎有了一点点眉目，就这能解释为什么两份代码里面同一个<code>signal()</code>，但是真正执行的代码不一样。一个疑惑解决了，但是为什么<code>gcc</code>编译的时候会出现这样的问题？还有这个<code>sysv_signal</code>和<code>bsd_signal</code>到底是什么？这是时候只能继续google了，功夫不负有心人，终于在Linux编程手册上找到了解答。</p>
<h2 id="Linux-Programmer’s-Manual-的解答"><a href="#Linux-Programmer’s-Manual-的解答" class="headerlink" title="Linux Programmer’s Manual 的解答"></a>Linux Programmer’s Manual 的解答</h2><p>详细信息点击<a href="http://man7.org/linux/man-pages/man2/signal.2.html" target="_blank" rel="noopener">signal</a></p>
<blockquote>
<p>The behavior of signal() varies across UNIX versions, and has also varied historically across different versions of Linux.  Avoid its use: use sigaction(2) instead.  See Portability below.</p>
</blockquote>
<p>大体意思就是说，<code>signal()</code>这东西有历史包袱，会在不同的Unix和Linux上表现不一致。接着往下看</p>
<blockquote>
<p>System V also provides these semantics for signal().  This was bad because the signal might be delivered again before the handler had a chance to reestablish itself.  Furthermore, rapid deliveries of the same signal could result in recursive invocations of the handler.</p>
<p>BSD improved on this situation, but unfortunately also changed the semantics of the existing signal() interface while doing so.  On BSD, when a signal handler is invoked, the signal disposition is not reset, and further instances of the signal are blocked from being delivered while the handler is executing.  Furthermore, certain blocking system calls are automatically restarted if interrupted by a signal handler (see signal(7)).  </p>
</blockquote>
<p>这里说有两种<code>signal()</code>，一种<code>System V</code>的，一种<code>BSD</code>的，BSD的<code>signal()</code>改善了System V的，在BSD，<code>signal()</code><strong>不会reset</strong>信号处理函数，多个信号同时到达的时候会阻塞，阻塞的系统调用被中断的时候会自动重启。这不就正好对应上面提到的<code>sysv_signal()</code>（sysv就是System V的缩写）和<code>bsd_signal()</code>！这时，echo_server为什么只能处理一个子进程就能解释了，因为它真正调用的是<code>sysv_signal()</code>，由System V实现的，<strong>会reset</strong>信号处理函数。同样的道理test真正调用的是<code>bsd_signal()</code>，由BSD实现，<strong>不会reset</strong>信号处理函数，所以可以一直处理所有子进程。好的，关于<code>sysv_signal()</code>和<code>bsd_signal()</code>是什么的问题解决了。点击了解更多关于<a href="http://man7.org/linux/man-pages/man3/sysv_signal.3.html" target="_blank" rel="noopener">sysv_signal()</a>和<a href="http://man7.org/linux/man-pages/man3/bsd_signal.3.html" target="_blank" rel="noopener">bsd_signal()</a>，里面有更详细的说明。</p>
<p>剩下的问题就是为什么一个<code>signal()</code>编译的时候会变成两个不同的函数？其实手册中也有说明，这里我使用的是本机（ubuntu 16.04 LTS)的man signal得到的。</p>
<blockquote>
<p>The situation on Linux is as follows:</p>
<p>The kernel’s signal() system call provides System V semantics.</p>
<p>By default, in glibc 2 and later, the signal() wrapper function does not invoke the kernel system call.  Instead, it calls sigaction(2) using flags that supply BSD  semantics. This  default  behavior  is  provided  as  long as the _BSD_SOURCE feature test macro is defined.  By default, _BSD_SOURCE is defined; it  is  also  implicitly  defined  if  one defines _GNU_SOURCE, and can of course be explicitly defined.</p>
<p>On  glibc  2  and later, if the _BSD_SOURCE feature test macro is not defined, then signal() provides System V semantics.  (The default implicit definition of  _BSD_SOURCE  is not  provided  if one invokes gcc(1) in one of its standard modes (-std=xxx or -ansi) or defines various other feature test  macros  such  as  _POSIX_SOURCE,  _XOPEN_SOURCE,  or _SVID_SOURCE; see feature_test_macros(7).)</p>
</blockquote>
<p>总结就是：定义了<code>_BSD_SOURCE</code>这个宏，<code>signal()</code>就会编译成BSD的版本，也就是不reset信号处理函数，阻塞相同信号，自动唤醒中断的系统调用，然后<code>_BSD_SOURCE</code>是默认定义的。<strong>但是</strong>如果你使用了gcc  -std=xxx or -ansi <strong>编译选项</strong>，或者使用了<code>_POSIX_SOURCE</code>,  <code>_XOPEN_SOURCE</code>,  or <code>_SVID_SOURCE</code>这些宏，那么<code>_BSD_SOURCE</code>这个宏就<strong>不再自动定义</strong>了，<code>signal()</code>就变成System V的版本。这就是我前面提到了gcc的编译选项和编译宏会影响signal()的真正的行为的解释。</p>
<p>好了真相大白了，在echo_server中我确实使用了<code>std=c11</code>的编译选项，然后我去掉std=c11这个编译选项，再用objdump查看符号，发现还是不对。这个时候我怀疑肯定是socket编程有关的头文件里面的宏影响了。然后我导出了编译时的宏定义，一看果然有问题</p>
<p>命令：<code>gcc -I../comm -E -dM echo_server.c &gt; echo_server.macro</code>使用<code>-E</code> 和<code>-dM</code>参数就可以导出编译宏，发现里面确实含有<code>_POSIX_SOURCE</code>。终于一切都水落石出了。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>简单说一下Linux Programmer’s Manual中括号()里的数字是什么含量，</p>
<ol>
<li>一般命令</li>
<li><p>系统调用</p>
</li>
<li><p>库函数，涵盖C标准函数库</p>
</li>
<li><p>特殊文件（通常是/dev中的设备）和驱动程序</p>
</li>
<li><p>文件格式和约定</p>
</li>
<li><p>游戏和屏保</p>
</li>
<li><p>杂项</p>
</li>
<li><p>系统管理命令和守护进程</p>
</li>
</ol>
<p>例如signal(2)就是系统调用。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然知道问题是由于<code>signal()</code>行为不确定导致的，那么自己写一个确定的signal函数就完事了啊。用<code>sigaction()</code>来代替signal。关于<code>sigaction()</code>的用法网上有很多，我就不细说了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span>	<span class="keyword">void</span>	<span class="title">Sigfunc</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//Signal首字母大写区分signal</span></span><br><span class="line"><span class="function">Sigfunc * <span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signo, Sigfunc *func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = func;</span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	act.sa_flags |= SA_RESTART;		<span class="comment">//重启因为信号处理被中断的慢系统调用，例如accept,read</span></span><br><span class="line">	<span class="keyword">if</span> (sigaction(signo, &amp;act, &amp;oldact) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> SIG_ERR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> oldact.sa_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>本来就是想照着书本实现一下简单的子进程回收，防止出现僵尸进程，没有想到最后搞出那么多花样。花了我整整一天的时间，除了吃饭就在干这个。Linxu系统编程真的不是一件简单的事情，一个signal()居然牵扯到那么多编译相关的问题，还遇上了signal()这种历史遗留问题，可是网上关于signal()的资料都是讲用法，很少有提到signal()这个函数应该避免使用。其实很多东西都已经写在文档里面，可是大多数人都没有耐心去看文档，而且也是全英文，不友好。我自己也不看文档，有问题都是直接google。但是这种<strong>最容易得到的知识，往往价值是相对比较低的，而且可能是错误的。真正有价值的东西，需要花时间去深挖，去积累。</strong>要养成看文档的好习惯。</p>
<p>虽然花了一天时间，但还是很开心，因为问题解决了，困惑消除了，很有成就感。学习编程那么久，也碰到过不少”神奇”的问题，多半都没有解决，这次算是一个里程碑吧。以后遇到问题，还有继续刨根问底！</p>
<p>最后一点感悟就是，C/C++的工程里，随便改一个构建系统的一个参数或者一个编译宏，都可能产生巨大的影响。不熟悉的东西，最好不要乱试。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="http://zheming.wang/blog/2011/02/17/65C9E90A-8D99-46DA-AC8D-F4D4EC825CD8/" target="_blank" rel="noopener">http://zheming.wang/blog/2011/02/17/65C9E90A-8D99-46DA-AC8D-F4D4EC825CD8/</a> </p>
<p> <a href="http://man7.org/linux/man-pages/man2/signal.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/signal.2.html</a> </p>
<p> <a href="https://blog.csdn.net/Move_now/article/details/60591018" target="_blank" rel="noopener">https://blog.csdn.net/Move_now/article/details/60591018</a> </p>
<p> <a href="https://www.infoq.cn/article/linux-signal-system" target="_blank" rel="noopener">https://www.infoq.cn/article/linux-signal-system</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/07/Linux-Unix-信号处理signal-函数/" data-id="ck3ujzyyj0000f4aj9021sov8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux服务器编程/">Linux服务器编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-线程安全的单例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/23/C-线程安全的单例/" class="article-date">
  <time datetime="2019-10-23T07:31:55.000Z" itemprop="datePublished">2019-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/23/C-线程安全的单例/">C++线程安全的单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程并行执行的程序中，对共享数据的访问或修改可能由于<strong>执行顺序的不确定</strong>，导致运行结果与代码设计者的原意相违背。为了保证代码原有的逻辑，在多线程的情况下可能需要用到一些同步或互斥的操作来保证线程安全。人的思考方式是单线程的，所以有时候看着很合理的代码逻辑，在多线程环境却出bug。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>最简单的设计模式之一，它的含义是这个类只能有<strong>唯一的对象实例</strong>。一般的单例对外的接口如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingleInstance * <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> SingleInstance *pInstance;</span><br><span class="line">    SingleInstance();<span class="comment">//private禁止外部构造对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>单例模式按<strong>实例创建的时机</strong>不同，可以分为<strong>懒汉式</strong>和<strong>饿汉式</strong>：</p>
<ul>
<li><strong>懒汉式</strong>：实例并不会提前创建好，只有当你<strong>第一次</strong>去访问的时候才会创建出唯一的实例，后面的访问会直接返回第一次创建的实例。</li>
<li><strong>饿汉式</strong>：<strong>提前</strong>创建实例，无论什么时候访问，都只能返回提前创建好的实例。</li>
</ul>
<h3 id="普通懒汉式单例实现"><a href="#普通懒汉式单例实现" class="headerlink" title="普通懒汉式单例实现"></a>普通懒汉式单例实现</h3><p>懒汉式的实现，先把实例指针初始化为<code>nullptr</code>，在<code>getInstance()</code>的调用过程中去检查实例是否已经被创建，如没有则创建，若已经创建好了，则直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::pInstance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)<span class="comment">//考虑多个线程都运行到这一行代码，会发生什么影响</span></span><br><span class="line">    &#123;</span><br><span class="line">        pInstance = <span class="keyword">new</span> SingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::SingleInstance()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式单例实现"><a href="#饿汉式单例实现" class="headerlink" title="饿汉式单例实现"></a>饿汉式单例实现</h3><p>饿汉式的实现，在定义静态数据成员的时候就new一个实例出来，这发生在所有代码运行前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::pInstance = <span class="keyword">new</span> SingleInstance;</span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::SingleInstance()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例"></a>线程安全的单例</h2><p>说了那么多，那单例和线程安全有什么关系，怎么样实现的单例线程不安全呢？</p>
<h3 id="饿汉式本身线程安全"><a href="#饿汉式本身线程安全" class="headerlink" title="饿汉式本身线程安全"></a>饿汉式本身线程安全</h3><p>对于<strong>饿汉式</strong>单例，本身就是线程安全的，因为实例的创建发生在所有代码运行前。</p>
<h3 id="加锁的懒汉式单例"><a href="#加锁的懒汉式单例" class="headerlink" title="加锁的懒汉式单例"></a>加锁的懒汉式单例</h3><p>对于<strong>普通懒汉式</strong>的单例，在判断指针是否为空这里，如果是在多线程的情景下，可能会出现多个线程判断<code>if (pInstance == nullptr)</code>均成立，然后去创建了多个实例，这就违反了单一实例的原则，同时也会内存泄露。所以在这个地方，必须加锁用于互斥。</p>
<p>先简单说一下怎么加锁，C++11以后提供了多线程库的支持，使用<code>mutex</code>和<code>unique_lock</code>就可以很简单地实现加锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m;<span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m);<span class="comment">//从这里开始加锁,使用mutex初始化会自动加锁</span></span><br><span class="line">    proc;</span><br><span class="line">&#125;<span class="comment">//在lck离开作用域析构的时候会自动解锁，也可以显式地使用lck.lock或者lck.unlock来进行操作</span></span><br></pre></td></tr></table></figure>
<p>那么我们来给懒汉加个锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m;<span class="comment">//这里是全局锁，也可以把这个锁放在SingleInstance里面作为静态成员变量</span></span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::pInstance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)<span class="comment">//double check</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m)；</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pInstance = <span class="keyword">new</span> SingleInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离开lck作用域析构解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::SingleInstance()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咦，有人会奇怪，为什么要判断两次<code>if (pInstance == nullptr)</code>。当初我也很疑惑，去掉最外层的判断逻辑是否正确呢，答案是正确的。这个称为<strong>double check</strong>，是为了提升性能。首先加锁是会对系统造成较大的性能消耗的。如果没有最外层的判断，那么每次<code>getInstance()</code>都要构造锁加锁，然后再析构锁解锁，性能影响是很大，而且没有必要。只有<code>pInstance==nullptr</code>才有申请实例的可能，才有出现线程安全问题的可能，才有加锁的必要。所以说这个<strong>double check</strong>就是一个套路啦，在其他用到锁的场合应该都能应用上。</p>
<p><strong>这样就完美了吗？</strong></p>
<p><code>pInstance = new SingleInstance;</code>这行代码在执行时会进行许多工作，内存申请，对象构造，指针赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pInstance = <span class="keyword">new</span> SingleInstance;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">memory = allocate();<span class="comment">//1内存申请</span></span><br><span class="line">construct(memory);  <span class="comment">//2对象构造</span></span><br><span class="line">pInstance = memory;	<span class="comment">//3指针赋值</span></span><br></pre></td></tr></table></figure>
<p>在编译神秘的优化下，可能发生<strong>指令的重排</strong>，例如执行顺序为1,3,2。对单线程来说没有很大的影响，但是在多线程环境下，在3执行完，把<code>pInstance</code>置为非空后，刚好其他线程抢占了CPU，那么这个线程获取实例时就会获取到了一个没有构造好的对象，导致逻辑出错。一般的解决方法是加一个<strong>局部变量做缓冲</strong>。我看到有网上的资料提过，还要加<strong>内存屏障</strong>。 因为CPU有一级二级缓存，CPU的计算结果并不是及时更新到内存的,所以在多线程环境，不同线程间共享内存数据存在可见性问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line">SingleInstance * SingleInstance::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(m)；</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = <span class="keyword">new</span> SingleInstance;<span class="comment">//先用局部变量记录起来</span></span><br><span class="line">            memory_barrier();<span class="comment">//保证前后代码执行的顺序性</span></span><br><span class="line">            pInstance = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离开lck作用域析构解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写的话应该是最安全，但逻辑也是最复杂，性能也比较差。除了给懒汉加锁，还有没有其他的方式呢？答案是有的。</p>
<h3 id="局部静态变量的懒汉单例（C-11支持）"><a href="#局部静态变量的懒汉单例（C-11支持）" class="headerlink" title="局部静态变量的懒汉单例（C++11支持）"></a>局部静态变量的懒汉单例（C++11支持）</h3><p>不再把实例作为类的静态成员，而是把实例放到<code>getInstance()</code>函数中，作为其中的<strong>静态局部变量</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingleInstance &amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SingleInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SingleInstance &amp; SingleInstance::getInstance()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> SingleInstance instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleInstance::SingleInstance()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>g++</code>编译的时候注意加上 <code>-std=c++11</code>的参数。C++11 保证静态局部变量的初始化过程是线程安全的。 这种方式既简洁又高效，首推这个。要注意的是之前<code>getInstance()</code>返回指针，现在返回的是<strong>引用</strong>，如果不是引用，返回过程就有拷贝，就会出现多实例，违背单例原则。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例实现分为懒汉式和饿汉式。</p>
<p>懒汉式以时间换空间， 适应于访问量较<strong>小</strong>时 ，如果要使用首推局部静态变量的懒汉单例。</p>
<p>饿汉式以空间换时间 ，适应于访问量较<strong>大</strong>时 。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>一个简单的单例模式涉及到多线程的问题就会变得如此复杂。很多看似简单的问题背后，都会有很多深奥的知识。探索的过程固然很累，但是如果学习到新的知识，还是会感到快乐的。这就是程序员学习的动力吧！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文参考网络上已有资料，自己整合做的总结。</p>
<p><a href="https://juejin.im/post/5d692773f265da03986c0832#heading-13" target="_blank" rel="noopener">https://juejin.im/post/5d692773f265da03986c0832#heading-13</a></p>
<p><a href="https://blog.csdn.net/ll641058431/article/details/50056597" target="_blank" rel="noopener">https://blog.csdn.net/ll641058431/article/details/50056597</a></p>
<p> <a href="https://blog.csdn.net/qq_36922927/article/details/84977365#3_double_check_42" target="_blank" rel="noopener">https://blog.csdn.net/qq_36922927/article/details/84977365#3_double_check_42</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/23/C-线程安全的单例/" data-id="ck3ujzyyz0003f4ajy24ud9hk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程多进程/">多线程多进程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-C-内存泄露定位" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/08/C-内存泄露定位/" class="article-date">
  <time datetime="2019-05-08T13:32:03.000Z" itemprop="datePublished">2019-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/08/C-内存泄露定位/">C 内存泄露定位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>内存泄露是我认为在C或C++项目上最难处理的一个bug，由于没有明显的现象，可能要到某一天，服务器内存耗尽后，申请不到新的内存，程序报错才能发现程序有内存泄露的现象。如果没有足够的监控或者维测的统计，很难发现内存泄露的原因。</p>
<h2 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h2><p>首先并不是说程序运行中有没释放的内存就是内存泄露。因为程序本身逻辑的运行，就需要一些内存用于记录信息。程序的运行，或多或少地会从堆中申请内存，但是一定保证，这个内存，还可以释放，还回去给操作系统。假如一个服务器程序为一个客户端提供服务时，需要申请一定的内存，这是程序本身的逻辑决定的。但当这个客户端完成服务，断开连接后，刚刚申请的那些内存一定要保证全部释放。简单的说，就是申请的内存，要能还回去。</p>
<h2 id="为什么出现内存泄露"><a href="#为什么出现内存泄露" class="headerlink" title="为什么出现内存泄露"></a>为什么出现内存泄露</h2><p>C或C++中，动态申请的内存，例如<code>malloc</code>或<code>new</code>申请处理的内存，但是没有释放，也没有记录下指向申请的那片内存的指针，最后无法释放这片内存。举个简单的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数从堆中申请了100个字节的内存，<code>p</code>是指向这片内存的指针。但是函数没有把<code>p</code>当成返回值提供给调用函数。<code>GetMemory</code>函数执行完后，<code>p</code>的值就不得而知了，既然指向内存的指针没了。那么想释放内存就无从下手了。只有程序没有结束，申请的这片内存就没法归还给操作系统。内存泄露一次两次不会有很大的影响，但是如果跑的是服务器的程序，日积月累，肯定会把内存耗尽，最终无法正确提供服务。</p>
<h1 id="定位思路"><a href="#定位思路" class="headerlink" title="定位思路"></a>定位思路</h1><p>明白为什么会内存泄露后，肯定首先瞄准的目标是申请内存的地方。你先要知道是哪里申请的内存。什么函数，函数里面的哪一行，申请的多大的内存。对于大的项目，申请内存的地方到处都是，直接走查代码就跟大海捞针一样，不科学。</p>
<p>首先我们需要做一个内存监控模块。简单来说就是一个hash表的结构。每次申请内存生成一个hash结点，插入到hash表中去。释放这片的内存的时候，从hash表中移除。如果程序运行过程中，这个hash表变得越来越大，你就要怀疑程序是不是有内存泄露的现象。</p>
<p>怎么设计这个hash表呢，最简单的方式就是把申请内存的地址<code>addr</code>作为hash表的key，每次申请内存的地址可以作为唯一标识这块内存的<code>key</code>，<code>value</code>的话看你想记录多少信息了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetMem(size)   MyGetMem(size, __FUNCTION__, __LINE__)</span></span><br><span class="line">#采用宏可以隐式地把函数名，行号等信息传递进申请内存的函数，方便记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> sturct </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr</span><br><span class="line">&#125;Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> sturct </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> funcName[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> line;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">&#125;Value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Key k;</span><br><span class="line">    Value v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你只需要实现这个hash表的接口，例如插入，删除，查找等接口。就可以实现一个简单的内存统计模块了。</p>
<p>其实不需要一定是hash表的数据结构，只要是方便查找的结构就可以了。可以底层用红黑树，平衡树什么跳跃表等等来实现。只要是一种查找速度快的数据结构即可。C++中可以直接用map这种数据结构。C语言就只能直接写了，苦逼啊。。。</p>
<p>这个内存监控的模块只能帮你发现泄露的内存是哪里申请的，具体为什么会泄露也只能自己看代码，开调试工具调试了。</p>
<p>似乎也有一些内存泄露定位的工具<code>valgrind</code>，但是由于我工作上的业务代码是跑在特定的嵌入式平台上的，根本跑不了这些东西，所有东西都要自己手写去实现，太痛苦了，真的羡慕那些开发的程序跑在X86上面程序员，有太多方便的工具了。</p>
<h2 id="代码改进"><a href="#代码改进" class="headerlink" title="代码改进"></a>代码改进</h2><p>其实代码编写的时候就有一些方法可以更好地管理申请的内存。方便理清逻辑，避免因为代码逻辑错误导致内存泄露。如果是服务端的程序。业务逻辑应该是比较单一的，需要面对的仅仅是高并发，但是每次并发的请求处理逻辑变化不大。所以内存使用是可以根据用户数来预估的。</p>
<p>首先是内存的管理，使用内存池的方式，并对内存做分类。可以采取类型和大小的两种分类。</p>
<p>这里举个例子：</p>
<p>根据使用内存的<strong>用途</strong>来分类。</p>
<ol>
<li>报文存储内存</li>
<li>模块消息交互内存</li>
<li>实例区域内存</li>
</ol>
<p>根据<strong>大小</strong>分类</p>
<ol>
<li>64字节的内存1000个</li>
<li>128字节的内存500个</li>
<li>1024字节的内存2000个</li>
<li>……</li>
</ol>
<h2 id="发现的一些内存泄露的bug"><a href="#发现的一些内存泄露的bug" class="headerlink" title="发现的一些内存泄露的bug"></a>发现的一些内存泄露的bug</h2><p>以下代码均是伪码</p>
<ol>
<li><p>申请的内存都要插入某个释放的队列保存起来的，但是插入释放队列是有条件。满足一定条件才能插入队列。但是原来的代码中对不满足插入队列的内存没有释放，导致内存泄露</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">queue</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buffer = GetMem() <span class="comment">//申请内存</span></span><br><span class="line">    <span class="keyword">if</span> ()</span><br><span class="line">    &#123;</span><br><span class="line">        insert(<span class="built_in">queue</span>, buffer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//这里缺少了free(buffer)，因为没有放入释放队列，就要马上释放</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑处理完后要释放内存</span></span><br><span class="line"><span class="keyword">void</span> freeQueue(<span class="built_in">queue</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//释放队列中所有结点内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>多进程，使用共享内存通信。有两个进程会调用同一个函数申请内存，并把地址记录到共享内存的一个地方。可能导致相互覆盖。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Buffer *buffer </span><br><span class="line">&#125; TaskData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//入参是指向共享内存的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetBuffer</span><span class="params">(TaskData *taskData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (taskData-&gt;buffer != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		taskData-&gt;buffer = GetMem()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程A:</span><br><span class="line">GetBuffer(taskData)</span><br><span class="line"></span><br><span class="line">进程B:</span><br><span class="line">GetBuffer(taskData)</span><br></pre></td></tr></table></figure>
<p> 两个进程都跑到line 9的时候，发现<code>buffer</code>是NULL，那就都会申请内存，最后导致后一个申请的地址覆盖了前一个申请的地址。申请的地址没记录下来，肯定没法释放了。</p>
</li>
<li><p>用一个数组来记录申请的内存。数组下标没有正确更新，导致新申请的内存覆盖了旧的内存。原意是申请到内存，记录在数组中，用<code>memNum</code>作为下标，然后<code>memNum</code>自增。但是会有异常流程导致内存记录到数组里面去了，但是<code>memNum</code>没增加，那下次进入这个函数，申请的内存就会覆盖掉前面的。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Buffer sendMem[<span class="number">100</span>]</span><br><span class="line">	<span class="keyword">int</span> memNum = <span class="number">0</span>;</span><br><span class="line">&#125; SendPara</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(SendPara sendPara)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buffer = GetMem()</span><br><span class="line">    sendPara.sendMem[memNum] = buffer</span><br><span class="line">    <span class="keyword">if</span> (xxx) <span class="comment">//遇到异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    memNum++  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较简单的情况，申请内存和释放内存都在一个函数里面。这样内存泄露肯定是因为函数没跑到释放return返回了。</p>
<p>复杂的情况。申请的内存需要经过多个函数处理，最后才释放。这个时候一般要关注，申请的内存是不是都记录在某个结构体，某个队列，某个数组里面。有没有相互覆盖的情况。我找的bug里大多是这种情况。核心的地方就是在于申请的内存有没有记录下来，在释放的时候还能不能找到那个地址。</p>
<p>至于那种根本就没写释放的。。。那就不知道代码评审是怎么过的了。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/08/C-内存泄露定位/" data-id="ck3ujzyz40007f4aj2dyzxyqb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-内存申请与释放" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/21/内存申请与释放/" class="article-date">
  <time datetime="2019-04-21T06:27:31.000Z" itemprop="datePublished">2019-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/21/内存申请与释放/">内存申请，初始化与释放</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在实现业务代码的时候，总不可避免地要动态申请内存。在C语言中，没有自动回收内存的机制，所以必须手动释放内存。如果没有正确释放内存，就会出现内存泄露。如果是在服务器端的程序出现内存泄露，那必定会导致服务不稳定，长期运行总会耗尽内存而导致无法新申请出内存，影响业务。</p>
<p>在C语言中，申请内存调用的是alloc类函数（之所以说类，是因为有<code>malloc</code> <code>calloc</code> <code>realloc</code>三种），释放内存使用free，这些个函数都定义在<code>stdlib.h</code>中。简单说一下alloc函数之间的区别，网上也有很多资料。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;<span class="comment">//申请size bytes的一片连续地址空间，不初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span> <span class="params">(<span class="keyword">size_t</span> num, <span class="keyword">size_t</span> size)</span></span>;<span class="comment">//申请num*size bytes的一片连续地址空间，初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span> <span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span>;<span class="comment">//改变已经申请内存空间的大小（可扩充可收缩），ptr也应该指向一片动态申请的内存</span></span><br><span class="line"><span class="comment">//realloc会保留原有的数据。如果是收缩，则新内存为原来内存内容的一部分截取，如果是扩展，则会拷贝原来所有内容并且新增空间，新增的空间不会初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="问题1：申请的内存是否需要初始化？"><a href="#问题1：申请的内存是否需要初始化？" class="headerlink" title="问题1：申请的内存是否需要初始化？"></a>问题1：申请的内存是否需要初始化？</h2><p>这个要根据具体的业务逻辑来分析。理论上来说，保证每一块内存都初始化是最保险的，但是会涉及性能的开销。因为调用<code>memset</code>也是很消耗资源的。一般的客户端软件对性能不敏感，但是在服务器上就不一样了。例如通信基站上的程序，对性能异常的敏感，有时候多1ms的延迟都会导致出错。如果对于大片的内存，全部都初始化太浪费性能。</p>
<p>首先要分析，这片内存的使用场景：</p>
<ul>
<li>如果申请出内存后的第一步操作就是覆写内存，那大可不必初始化。</li>
<li>如果申请的内存有可能先被读，那就必须初始化保证逻辑的正确。</li>
</ul>
<h3 id="不需要初始化"><a href="#不需要初始化" class="headerlink" title="不需要初始化"></a>不需要初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如业务的逻辑是做数据的拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">copyString</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str) + <span class="number">1</span>; <span class="comment">//末尾空字符</span></span><br><span class="line">    <span class="keyword">char</span> *ret = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(ret, str); <span class="comment">//申请的内存空间马上就会被覆写，不需要初始化</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="keyword">char</span> *copy = copyString(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="需要初始化"><a href="#需要初始化" class="headerlink" title="需要初始化"></a>需要初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务的逻辑收到报文，即把对应标志位置1，默认状态肯定都是没收到</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOT_RCV 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCV 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkIsRcv</span><span class="params">(<span class="keyword">char</span> *packetStatus, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> packetStatus[index] == RCV</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line"><span class="keyword">void</span> setPacketFlag((<span class="keyword">char</span> *packetStatus, <span class="keyword">int</span> index, <span class="keyword">char</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">    packetStatus[index] = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	sacnf(<span class="string">"%d"</span>, &amp;n); <span class="comment">//报文数量</span></span><br><span class="line">    <span class="keyword">char</span> *packetStatus = <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(status, <span class="number">0</span>, n); <span class="comment">//如果不初始化，里面的值是不确定的，后面读取出来就会导致逻辑出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题2：如何正确释放内存？"><a href="#问题2：如何正确释放内存？" class="headerlink" title="问题2：如何正确释放内存？"></a>问题2：如何正确释放内存？</h2><p>要做到完全避免内存泄露，在大型的C项目上是个难题，特别是业务逻辑很复杂时。这里只说一下简单的场景:</p>
<p><code>free</code>一个指针前，需要注意释放这个指针指向的结构体内部的指针指向的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value <span class="comment">//结构体内部的指针，指向动态申请的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeNode</span><span class="params">(struct node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p-&gt;value); <span class="comment">//一定要把value指向的内存先释放，再释放p，不然会导致再也无法释放value指向的内存</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样也还是不安全，因为value是<code>void *</code>类型指针，可能value还是指向一个结构体，里面也有动态申请的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myArray</span> //一个动态长度的<span class="title">int</span>数组</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">node</span>));</span></span><br><span class="line">p-&gt;value = (<span class="keyword">void</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct myArray));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myArrayp</span> *<span class="title">q</span> = (<span class="title">struct</span> <span class="title">myArrayp</span> *)<span class="title">p</span>-&gt;<span class="title">value</span>;</span></span><br><span class="line">q-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(q-&gt;size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为这种结构体封装一个freeXXX函数，保证这个函数可以完全释放内存空间。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeArray</span><span class="params">(struct myArray *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeNode</span><span class="params">(struct node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freeArray(p-&gt;value); <span class="comment">//不要直接调用free，而是调用封装的freeXXX函数</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实解决问题的核心还是在于封装，某种类型的结构体，需要封装一个创建函数，和释放函数。保证释放函数可以把创建函数申请的内存和代码运行期间申请的内存全部释放掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/21/内存申请与释放/" data-id="ck3ujzyz30006f4aje4k25aux" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存管理/">内存管理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-github上面部署CI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/17/github上面部署CI/" class="article-date">
  <time datetime="2019-04-17T14:49:35.000Z" itemprop="datePublished">2019-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/17/github上面部署CI/">为某个github的项目部署CI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在商业公司的项目管理里，持续集成（Continuous Integration，简称CI）是必须的一环。刚开始工作的时候，也不太懂持续集成是什么意思，慢慢接触到项目，也有了一定的理解。简单来说CI就持续编译项目源码，进行测试，并部署。每次项目组的成员提交的代码，都要走一遍编译，测试，部署的流程。而且这个过程全自动化完成。</p>
<p>个人感觉CI还是有很大的好处的，可以及时的暴露问题，可以把代码的测试细化到git上面的每一次commit，更容易定位问题和提升项目质量。</p>
<p>在某国外搜索引擎中了解到了<a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org</a>，可以给github上的公开repo部署CI，教程网上一搜就一大堆，就不具体说了，说说遇到的坑和学习到的东西。</p>
<p>首先travis是通过一个<code>.travis.yml</code>文件来自动化构建的。<code>yml</code>似乎是一种配置文件的格式，应该跟<code>json</code>差不多，在官网上看看语法就开始用了。我的项目很简单，因为我要跑CI的repo是fork的Redis，所以已经写好了测试的脚本。我只需要把构建的流程走一下就好了。</p>
<p>官网的说法是，只要你把正确的.travis.yml放在repo的根目录下，并且在travis网站，用github账户登录并且激活这个仓库的构建。你以后每次push代码到仓库上，就能自动触发一次build</p>
<p>最后配置的.travis.xml差不多长这样：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">c</span></span><br><span class="line"><span class="attr">notifications:</span>     </span><br><span class="line"><span class="attr">  email:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">before_install:</span> <span class="string">chmod</span> <span class="string">+x</span> <span class="string">runtest-ci</span></span><br><span class="line"><span class="string">script</span> <span class="string">:</span> <span class="string">./runtest-ci</span></span><br></pre></td></tr></table></figure>
<p>意思是说项目用的C语言，每次build不需要邮件通知。使用root权限，给<code>runtest-ci</code>这个脚本执行权限，最后直接执行测试脚本。我这里面省略了部署项目的操作，因为我就是纯属想了解一下怎么自动化CI</p>
<p>然后<code>runtest-ci</code>也很简单</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">sudo apt-get install tcl</span><br><span class="line">chmod +x runtest runtest-cluster runtest-sentinel</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
<p>tcl是redis跑test需要的一个库，网上查了一下，似乎是一个tcl语言的解析器，还不太了解</p>
<p>让我比较疑惑的一个问题是，build失败和成功是怎么判定的呢？我的想法是应该是根据跑的shell脚本的返回来判定。如果脚本执行返回0，就是build succ。如果返回其他值，就是build error</p>
<p>还有刚开始用的时候，因为的测试脚本跑之前需要安装一个tcl这个库，由于我不知道默认服务器的哪个linux发行版，导致我不知道应该用apt-get还是yum或者其他的软件管理包。我是构建了一次，查看了log后才发现系统是ubuntu，可以用apt-get的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ export TRAVIS_COMPILER=gcc</span><br><span class="line">$ export CC=gcc</span><br><span class="line">$ export CC_FOR_BUILD=gcc</span><br><span class="line">$ gcc --version</span><br><span class="line">gcc (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>
<p>而且刚开始还因为没有加sudo 导致无法执行apt-get install 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install tcl</span><br><span class="line">E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)</span><br><span class="line">E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?</span><br><span class="line">The command &quot;apt-get install tcl&quot; failed and exited with 100 during .</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<p>travis真是很方便好用的自动化CI工具，只需要配置好.travis.xml文件和关联repo就可以部署好某个repo的CI。最后附上成果图</p>
<p><a href="https://travis-ci.org/licovery/redis-3.0-annotated" target="_blank" rel="noopener"><img src="https://travis-ci.org/licovery/redis-3.0-annotated.svg?branch=unstable" alt="Build Status"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/17/github上面部署CI/" data-id="ck3ujzyz10004f4ajhh7w77zr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CI-持续集成/">CI(持续集成)</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-my-first-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/my-first-blog/" class="article-date">
  <time datetime="2019-04-12T14:17:28.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/my-first-blog/">为什么写博客？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>互联网上面有太多的资料和资源可以获取，获取信息本身不难，如何有效地利用它们是一件困难的事情。我写这个博客是希望自己能把从网络上学习到的知识，经过自己的理解，用自己的逻辑思维方式再次表达出来，同时写作本身又是加深知识理解的一种方式。</p>
<p>其实我是有记录笔记的习惯的，一般是用印象笔记来记录下工作或者学习上的一些知识点，印象笔记中有大量但是零碎的知识记录。希望可以通过写博文的方式，把那些零碎的知识串联起来，形成一个相应的知识体系。</p>
<p>我是一个十分讨厌写作的人，我自认自己写作能力极差，但是我还是决定努力用自己有限的能力把博文写出来，也不是为了给谁看，就是想通过写作来总结一些知识和信息。</p>
<p>世界上有太多的未知值得我们去探索，希望自己能永远保持对知识的热忱！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/12/my-first-blog/" data-id="ck3ujzyz20005f4ajprpzea96" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/hello-world/" class="article-date">
  <time datetime="2019-04-12T14:14:07.680Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/12/hello-world/" data-id="ck3ujzyz50008f4aj5c7rg0y2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI-持续集成/">CI(持续集成)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux服务器编程/">Linux服务器编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程多进程/">多线程多进程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CI-持续集成/" style="font-size: 10px;">CI(持续集成)</a> <a href="/tags/Linux服务器编程/" style="font-size: 10px;">Linux服务器编程</a> <a href="/tags/内存管理/" style="font-size: 20px;">内存管理</a> <a href="/tags/多线程多进程/" style="font-size: 10px;">多线程多进程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/07/Linux-Unix-信号处理signal-函数/">Linux/Unix 信号处理signal()函数的坑——为什么僵尸进程总是清理不掉？</a>
          </li>
        
          <li>
            <a href="/2019/10/23/C-线程安全的单例/">C++线程安全的单例模式</a>
          </li>
        
          <li>
            <a href="/2019/05/08/C-内存泄露定位/">C 内存泄露定位</a>
          </li>
        
          <li>
            <a href="/2019/04/21/内存申请与释放/">内存申请，初始化与释放</a>
          </li>
        
          <li>
            <a href="/2019/04/17/github上面部署CI/">为某个github的项目部署CI</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Neo Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>